"use strict";/**
 * @module tree
 *
 * A small library of tree algorithms.
 *
 * @copyright (c) 2017 David Mesquita-Morris
 *
 * Licensed under the MIT and GPL v3 licences
 */var cov_1dald65fmc=function(){var path="/Users/david/Dropbox/Development/steelbreeze/graph/lib/node/tree.js",hash="a5568d3d0a3239bd04d31826d1dd613101c86fb7",global=new Function('return this')(),gcv="__coverage__",coverageData={path:"/Users/david/Dropbox/Development/steelbreeze/graph/lib/node/tree.js",statementMap:{"0":{start:{line:11,column:0},end:{line:11,column:62}},"1":{start:{line:13,column:0},end:{line:74,column:47}},"2":{start:{line:20,column:21},end:{line:20,column:23}},"3":{start:{line:21,column:8},end:{line:23,column:9}},"4":{start:{line:22,column:12},end:{line:22,column:30}},"5":{start:{line:24,column:8},end:{line:24,column:22}},"6":{start:{line:26,column:4},end:{line:26,column:31}},"7":{start:{line:35,column:21},end:{line:35,column:22}},"8":{start:{line:36,column:8},end:{line:41,column:9}},"9":{start:{line:37,column:22},end:{line:37,column:66}},"10":{start:{line:38,column:12},end:{line:40,column:13}},"11":{start:{line:39,column:16},end:{line:39,column:25}},"12":{start:{line:42,column:8},end:{line:42,column:26}},"13":{start:{line:44,column:4},end:{line:44,column:63}},"14":{start:{line:52,column:8},end:{line:56,column:9}},"15":{start:{line:53,column:12},end:{line:55,column:13}},"16":{start:{line:54,column:16},end:{line:54,column:28}},"17":{start:{line:57,column:8},end:{line:57,column:21}},"18":{start:{line:59,column:4},end:{line:59,column:27}},"19":{start:{line:67,column:21},end:{line:67,column:23}},"20":{start:{line:68,column:8},end:{line:70,column:9}},"21":{start:{line:69,column:12},end:{line:69,column:21}},"22":{start:{line:71,column:8},end:{line:71,column:22}},"23":{start:{line:73,column:4},end:{line:73,column:23}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:13,column:1},end:{line:13,column:2}},loc:{start:{line:13,column:17},end:{line:74,column:1}},line:13},"1":{name:"ancestors",decl:{start:{line:19,column:13},end:{line:19,column:22}},loc:{start:{line:19,column:29},end:{line:25,column:5}},line:19},"2":{name:"lowestCommonAncestorIndex",decl:{start:{line:34,column:13},end:{line:34,column:38}},loc:{start:{line:34,column:61},end:{line:43,column:5}},line:34},"3":{name:"isChild",decl:{start:{line:51,column:13},end:{line:51,column:20}},loc:{start:{line:51,column:36},end:{line:58,column:5}},line:51},"4":{name:"depth",decl:{start:{line:66,column:13},end:{line:66,column:18}},loc:{start:{line:66,column:25},end:{line:72,column:5}},line:66}},branchMap:{"0":{loc:{start:{line:36,column:8},end:{line:41,column:9}},type:"if",locations:[{start:{line:36,column:8},end:{line:41,column:9}},{start:{line:36,column:8},end:{line:41,column:9}}],line:36},"1":{loc:{start:{line:36,column:12},end:{line:36,column:62}},type:"binary-expr",locations:[{start:{line:36,column:12},end:{line:36,column:35}},{start:{line:36,column:39},end:{line:36,column:62}}],line:36},"2":{loc:{start:{line:38,column:19},end:{line:38,column:74}},type:"binary-expr",locations:[{start:{line:38,column:19},end:{line:38,column:31}},{start:{line:38,column:35},end:{line:38,column:74}}],line:38},"3":{loc:{start:{line:53,column:12},end:{line:55,column:13}},type:"if",locations:[{start:{line:53,column:12},end:{line:55,column:13}},{start:{line:53,column:12},end:{line:55,column:13}}],line:53},"4":{loc:{start:{line:74,column:10},end:{line:74,column:45}},type:"binary-expr",locations:[{start:{line:74,column:10},end:{line:74,column:22}},{start:{line:74,column:27},end:{line:74,column:44}}],line:74}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0,"23":0},f:{"0":0,"1":0,"2":0,"3":0,"4":0},b:{"0":[0,0],"1":[0,0],"2":[0,0],"3":[0,0],"4":[0,0]},_coverageSchema:"332fd63041d2c1bcb487cc26dd0d5f7d97098a6c"},coverage=global[gcv]||(global[gcv]={});if(coverage[path]&&coverage[path].hash===hash){return coverage[path];}coverageData.hash=hash;return coverage[path]=coverageData;}();++cov_1dald65fmc.s[0];Object.defineProperty(exports,"__esModule",{value:true});var Tree;++cov_1dald65fmc.s[1];(function(Tree){++cov_1dald65fmc.f[0];/**
     * Returns the ancestry of a node within a tree from the root as an array.
     * @param TNode A common type shared by all node instances within the tree.
     * @param node The node to return the ancestry for.
     */function ancestors(node){++cov_1dald65fmc.f[1];var result=(++cov_1dald65fmc.s[2],[]);++cov_1dald65fmc.s[3];for(var i=node;i!==undefined;i=i.parent){++cov_1dald65fmc.s[4];result.unshift(i);}++cov_1dald65fmc.s[5];return result;}++cov_1dald65fmc.s[6];Tree.ancestors=ancestors;/**
     * Returns the index of the lowest/least common ancestor given a pair of ancestrys.
     * @param TNode A common type shared by all node instances within the tree.
     * @param ancestry1 The ancestry of a node within the tree.
     * @param ancestry2 The ancestry of a node within the tree.
     * @returns The index of the lowest/least common ancestor or -1 if the nodes do not share any ancestry.
     */function lowestCommonAncestorIndex(ancestry1,ancestry2){++cov_1dald65fmc.f[2];var result=(++cov_1dald65fmc.s[7],0);++cov_1dald65fmc.s[8];if((++cov_1dald65fmc.b[1][0],ancestry1!==undefined)&&(++cov_1dald65fmc.b[1][1],ancestry2!==undefined)){++cov_1dald65fmc.b[0][0];var max=(++cov_1dald65fmc.s[9],Math.min(ancestry1.length,ancestry2.length));++cov_1dald65fmc.s[10];while((++cov_1dald65fmc.b[2][0],result<max)&&(++cov_1dald65fmc.b[2][1],ancestry1[result]===ancestry2[result])){++cov_1dald65fmc.s[11];result++;}}else{++cov_1dald65fmc.b[0][1];}++cov_1dald65fmc.s[12];return result-1;}++cov_1dald65fmc.s[13];Tree.lowestCommonAncestorIndex=lowestCommonAncestorIndex;/**
     * Tests a node to see if it is in the ancestry of another node.
     * @param TNode A common type shared by all node instances within the tree.
     * @param child The possible child node.
     * @param parent The parent node.
     */function isChild(child,parent){++cov_1dald65fmc.f[3];++cov_1dald65fmc.s[14];for(var i=child;i!==undefined;i=i.parent){++cov_1dald65fmc.s[15];if(i.parent===parent){++cov_1dald65fmc.b[3][0];++cov_1dald65fmc.s[16];return true;}else{++cov_1dald65fmc.b[3][1];}}++cov_1dald65fmc.s[17];return false;}++cov_1dald65fmc.s[18];Tree.isChild=isChild;/**
     * Returns the depth (number of edges from a node to the root) of a node.
     * @param TNode A common type shared by all node instances within the tree.
     * @param child The node to get the depth of.
     * @returns The number of edges between the node an the root node. Returns -1 an undefined node is passed.
     */function depth(node){++cov_1dald65fmc.f[4];var result=(++cov_1dald65fmc.s[19],-1);++cov_1dald65fmc.s[20];for(var i=node;i!==undefined;i=i.parent){++cov_1dald65fmc.s[21];result++;}++cov_1dald65fmc.s[22];return result;}++cov_1dald65fmc.s[23];Tree.depth=depth;})(Tree=(++cov_1dald65fmc.b[4][0],exports.Tree)||(++cov_1dald65fmc.b[4][1],exports.Tree={}));